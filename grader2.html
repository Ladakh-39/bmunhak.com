<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>bmunhak 채점하기</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/gh/sun-typeface/SUIT@2/fonts/variable/woff2/SUIT-Variable.css" rel="stylesheet" />
    <style>
        body { font-family: "SUIT Variable", -apple-system, BlinkMacSystemFont, "Apple SD Gothic Neo", "Malgun Gothic", sans-serif; background-color: #e5e7eb; }
        input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .mono { font-variant-numeric: tabular-nums; }
        .status-badge-idle { background:#e2e8f0; color:#0f172a; }
        .status-badge-generating { background:#dbeafe; color:#1d4ed8; }
        .status-badge-grading { background:#ede9fe; color:#6d28d9; }
        .status-badge-saving { background:#fef3c7; color:#92400e; }
        .status-badge-done { background:#dcfce7; color:#166534; }
        .status-badge-error { background:#fee2e2; color:#991b1b; }
        .answer-scratch { position: relative; width: 56px; height: 40px; border: 1px solid #cbd5e1; background: #fff; overflow: hidden; user-select: none; }
        .answer-scratch .scratchCanvas { position: absolute; inset: 0; width: 100%; height: 100%; cursor: default; touch-action: none; z-index: 2; }
        .answer-scratch .answer-value { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; font-weight: 900; color: #445394; z-index: 1; }
        .answer-scratch .answer-value.hidden { display: none; }
        .answer-scratch.revealed { border-color: #93c5fd; background: #eff6ff; }
        .answer-scratch.revealed .scratchCanvas { display: none; }
        .answer-scratch .scratch-hint { position: absolute; inset: 0; z-index: 3; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: 800; color: #e2e8f0; pointer-events: none; line-height: 1; }
        .answer-scratch.revealed .scratch-hint { display: none; }
    </style>
</head>
<body class="min-h-screen bm-auth-pending">
<header class="border-b border-slate-400 bg-[#7092BE] text-white overflow-hidden">
    <div class="mx-auto flex h-16 max-w-[1440px] items-center gap-4 overflow-hidden px-4">
        <div class="flex items-center min-w-[160px]">
            <a href="/index.html" class="block">
                <span class="block text-[34px] leading-none font-black tracking-tight text-[#33506a]">bmunhak</span>
            </a>
        </div>
        <nav class="hidden md:flex flex-1 items-center justify-center gap-5 text-[18px] leading-none font-semibold min-w-0 flex-nowrap whitespace-nowrap">
            <span class="room-secret-slot inline-flex items-center justify-center w-[104px] whitespace-nowrap">
                <a id="room-of-requirement" href="/board.html?b=room" class="room-secret-prehide leading-none transition-colors whitespace-nowrap" style="visibility:hidden;pointer-events:none;">필요의 방</a>
            </span>
            <a href="/board.html?b=notice" class="leading-none hover:underline whitespace-nowrap">공지사항</a>
            <a href="/board.html?b=intro" class="leading-none hover:underline whitespace-nowrap">가입인사</a>
            <a href="/board.html?b=free" class="leading-none hover:underline whitespace-nowrap">자유게시판</a>
            <a href="/board.html?b=qna" class="leading-none hover:underline whitespace-nowrap">질문</a>
            <a href="/grader.html" class="leading-none hover:underline whitespace-nowrap">채점하기</a>
            <a href="/my.html" class="leading-none hover:underline whitespace-nowrap">My Page</a>
        </nav>
        <div class="hidden md:flex items-center justify-end gap-3 min-w-[140px] text-sm font-semibold">
            <button id="btnSignupTop" type="button" class="hover:underline">회원가입</button>
            <button id="btnLoginTop" type="button" class="hover:underline">로그인</button>
            <span id="welcomeText" class="hidden text-sm font-bold"></span>
            <button id="btnLogoutTop" type="button" class="hidden hover:underline">로그아웃</button>
        </div>
        <button id="btnMenu" class="rounded-lg px-3 py-2 text-2xl md:hidden" type="button">☰</button>
    </div>
    <div id="mobileMenu" class="mx-auto hidden max-w-[1440px] px-4 pb-3 md:hidden">
        <div class="flex flex-col gap-2 text-base font-bold">
            <a id="room-of-requirement-mobile" href="/board.html?b=room" class="room-secret-prehide hidden px-3 py-2 rounded-lg transition-colors whitespace-nowrap" style="visibility:hidden;pointer-events:none;">필요의 방</a>
            <a href="/board.html?b=notice" class="rounded px-2 py-1 hover:bg-white/10">공지사항</a>
            <a href="/board.html?b=intro" class="rounded px-2 py-1 hover:bg-white/10">가입인사</a>
            <a href="/board.html?b=free" class="rounded px-2 py-1 hover:bg-white/10">자유게시판</a>
            <a href="/board.html?b=qna" class="rounded px-2 py-1 hover:bg-white/10">질문</a>
            <a href="/grader.html" class="rounded px-2 py-1 hover:bg-white/10">채점하기</a>
            <a href="/my.html" class="rounded px-2 py-1 hover:bg-white/10">My Page</a>
        </div>
        <div class="flex items-center gap-3 px-3 pt-2">
            <button id="btnSignupMobile" class="hover:underline" type="button">회원가입</button>
            <button id="btnLoginMobile" class="hover:underline" type="button">로그인</button>
            <button id="btnLogoutMobile" class="hidden hover:underline" type="button">로그아웃</button>
        </div>
    </div>
</header>

<main class="px-4 py-8">
    <section class="mx-auto max-w-[1180px] border border-slate-300 bg-white p-5 shadow-sm md:p-7">
        <div class="mb-5 flex flex-wrap gap-4">
            <div>
                <h1 class="text-3xl font-black text-slate-900 md:text-4xl">2027 마더텅 수능기출문제집<br />국어 독서 채점기</h1>
            </div>
            <div class="ml-auto w-full max-w-[440px] border border-slate-200 bg-slate-50 p-3">
                <div class="flex items-center justify-between gap-2">
                    <span class="text-xs font-black text-slate-500">상태 패널</span>
                    <span id="statusBadge" class="rounded-full px-2 py-1 text-xs font-black status-badge-idle">대기</span>
                </div>
                <div id="statusMsg" class="mt-2 text-xs font-black text-slate-600">범위를 설정하고 생성 버튼을 눌러주세요.</div>
                <div class="mt-3 grid grid-cols-3 gap-2 text-[11px] font-black">
                    <div class="rounded border border-green-200 bg-green-50 px-2 py-1 text-green-700">정답 O</div>
                    <div class="rounded border border-red-200 bg-red-50 px-2 py-1 text-red-700">오답 X</div>
                    <div class="rounded border border-amber-200 bg-amber-50 px-2 py-1 text-amber-700">미입력 !</div>
                </div>
                <div id="saveMeta" class="mt-3 hidden text-xs font-black text-slate-700"></div>
            </div>
        </div>

        <div class="grid grid-cols-1 gap-4 md:grid-cols-4">
            <div>
                <label for="subjectSelect" class="mb-1 ml-1 block text-xs font-black text-slate-400">과목 선택</label>
                <select id="subjectSelect" class="h-14 w-full border-2 border-slate-200 bg-slate-50 px-3 text-base font-black outline-none focus:border-blue-500">
                    <option value="humanities">마더텅 Ⅰ. 인문 (001~218)</option>
                    <option value="social">마더텅 Ⅱ. 사회 (001~157)</option>
                    <option value="science">마더텅 Ⅲ. 과학 (001~099)</option>
                    <option value="tech">마더텅 Ⅳ. 기술 (001~090)</option>
                    <option value="art">마더텅 Ⅴ. 예술 (001~044)</option>
                    <option value="mixed">마더텅 Ⅵ. 복합 지문 (001~036)</option>
                    <option value="mock1">마더텅 미니모의 1회 (01~17)</option>
                    <option value="mock2">마더텅 미니모의 2회 (01~17)</option>
                </select>
            </div>
            <div>
                <label for="startQ" class="mb-1 ml-1 block text-xs font-black text-slate-400">시작 번호</label>
                <input id="startQ" type="number" inputmode="numeric" class="mono h-14 w-full border-2 border-slate-200 bg-slate-50 px-3 text-center text-lg font-black outline-none focus:border-blue-500" />
            </div>
            <div>
                <label for="endQ" class="mb-1 ml-1 block text-xs font-black text-slate-400">끝 번호</label>
                <input id="endQ" type="number" inputmode="numeric" class="mono h-14 w-full border-2 border-slate-200 bg-slate-50 px-3 text-center text-lg font-black outline-none focus:border-blue-500" />
            </div>
            <div>
                <label aria-hidden="true" class="mb-1 ml-1 block text-xs font-black text-transparent">정렬용 라벨</label>
                <div class="grid grid-cols-3 gap-2">
                    <button id="btnBuild" type="button" class="h-14 bg-blue-600 px-3 text-sm font-black text-white hover:bg-blue-700">생성</button>
                    <button id="btnClear" type="button" class="h-14 bg-slate-200 px-3 text-sm font-black text-slate-700 hover:bg-slate-300">초기화</button>
                    <button id="btnGrade" type="button" class="h-14 bg-slate-900 px-3 text-sm font-black text-white hover:bg-black" disabled>채점</button>
                </div>
            </div>
        </div>

        <p class="mt-4 text-xs font-bold text-slate-500">숫자 1~5 입력 시 자동 다음칸 이동, Enter 채점, 붙여넣기(예: 1234512...) 지원</p>
        <div id="question-list" class="mt-5 grid grid-cols-4 gap-2 sm:grid-cols-6 md:grid-cols-8 lg:grid-cols-10"></div>

        <div id="summary" class="mt-5 hidden border border-blue-200 bg-blue-50 p-4"></div>
        <div id="wrongWrap" class="mt-4 hidden border border-slate-200 bg-slate-50 p-4">
            <h2 class="text-sm font-black text-slate-600">풀이 목록 (오답만 긁어서 정답 확인)</h2>
            <div id="wrongList" class="mt-2"></div>
        </div>
    </section>
</main>

<footer class="border-t border-slate-300 bg-[#d7d9de] py-6">
    <div class="mx-auto max-w-[1180px] px-4 text-center text-[44px] font-semibold tracking-tight text-[#36516b]">
        bmunhak.com
    </div>
</footer>

<script>
    const SUBJECT_RANGES = {
        humanities: { min: 1, max: 218 },
        social: { min: 1, max: 157 },
        science: { min: 1, max: 99 },
        tech: { min: 1, max: 90 },
        art: { min: 1, max: 44 },
        mixed: { min: 1, max: 36 },
        mock1: { min: 1, max: 17 },
        mock2: { min: 1, max: 17 }
    };

    const MOTHERTUNG_YEAR = 2027;
    const qs = new URLSearchParams(location.search);
    const sectionFromQs = String(qs.get("section") || "").trim().toLowerCase();

    const subjectSelect = document.getElementById('subjectSelect');
    const startQ = document.getElementById('startQ');
    const endQ = document.getElementById('endQ');
    const statusBadge = document.getElementById('statusBadge');
    const statusMsg = document.getElementById('statusMsg');
    const saveMeta = document.getElementById('saveMeta');
    const questionList = document.getElementById('question-list');
    const summary = document.getElementById('summary');
    const wrongWrap = document.getElementById('wrongWrap');
    const wrongList = document.getElementById('wrongList');
    const btnBuild = document.getElementById('btnBuild');
    const btnClear = document.getElementById('btnClear');
    const btnGrade = document.getElementById('btnGrade');
    const btnMenu = document.getElementById('btnMenu');
    const mobileMenu = document.getElementById('mobileMenu');

    let questionIds = [];
    let gradeBusy = false;
    let draftTimer = null;

    function getSubjectRange(subject) {
        const range = SUBJECT_RANGES[subject];
        if (!range) return { min: 1, max: 1 };
        return range;
    }

    function setDefaultRange() {
        const { min, max } = getSubjectRange(subjectSelect.value);
        startQ.value = String(min);
        endQ.value = String(max);
    }

    function setStatus(message) {
        statusMsg.textContent = message;
    }

    function setStatusPhase(phase, message) {
        const labels = {
            idle: "대기",
            generating: "생성중",
            grading: "채점중",
            saving: "저장중",
            done: "완료",
            error: "오류"
        };
        statusBadge.className = `rounded-full px-2 py-1 text-xs font-black status-badge-${phase}`;
        statusBadge.textContent = labels[phase] || "대기";
        if (typeof message === "string") setStatus(message);
    }

    function setSaveMeta({ attemptId, href }) {
        if (!attemptId || !href) {
            saveMeta.classList.add("hidden");
            saveMeta.innerHTML = "";
            return;
        }
        saveMeta.classList.remove("hidden");
        saveMeta.innerHTML = `저장 완료 (시도 #${attemptId}) · <a href="${href}" class="underline">기록 보기</a>`;
    }

    function updateActionButtons() {
        const hasQuestions = questionIds.length > 0;
        btnGrade.disabled = !hasQuestions || gradeBusy;
    }

    function getDraftKey(subject, start, end) {
        return `mt:v1:${subject}:${start}-${end}`;
    }

    function getCurrentDraftKey() {
        if (!questionIds.length) return "";
        return getDraftKey(subjectSelect.value, questionIds[0], questionIds[questionIds.length - 1]);
    }

    function buildAnswerPayload() {
        const payload = {};
        for (const qNum of questionIds) {
            const input = document.getElementById(`q-${qNum}`);
            if (!input) continue;
            const value = Number.parseInt(input.value, 10);
            if (!Number.isFinite(value) || value < 1 || value > 5) continue;
            payload[qNum] = value;
        }
        return payload;
    }

    function saveDraftNow() {
        if (!questionIds.length) return;
        const key = getCurrentDraftKey();
        if (!key) return;
        const payload = {
            answers: buildAnswerPayload(),
            updated_at: Date.now()
        };
        try {
            localStorage.setItem(key, JSON.stringify(payload));
        } catch (_a) {
            // ignore localStorage quota/privacy errors
        }
    }

    function queueDraftSave() {
        if (draftTimer) clearTimeout(draftTimer);
        draftTimer = setTimeout(() => {
            saveDraftNow();
        }, 300);
    }

    function clearCurrentDraft() {
        const key = getCurrentDraftKey();
        if (!key) return;
        try {
            localStorage.removeItem(key);
        } catch (_a) {
            // ignore localStorage errors
        }
    }

    function restoreDraftForCurrentRange() {
        if (!questionIds.length) return 0;
        const key = getCurrentDraftKey();
        if (!key) return 0;
        let restored = 0;
        try {
            const raw = localStorage.getItem(key);
            if (!raw) return 0;
            const parsed = JSON.parse(raw);
            const answers = parsed && typeof parsed === "object" ? parsed.answers || {} : {};
            for (const qNum of questionIds) {
                const input = document.getElementById(`q-${qNum}`);
                const mark = document.getElementById(`res-${qNum}`);
                if (!input || !mark) continue;
                const value = Number.parseInt(String(answers[qNum] || ""), 10);
                if (!Number.isFinite(value) || value < 1 || value > 5) continue;
                input.value = String(value);
                clearVisualState(input, mark);
                restored += 1;
            }
        } catch (_a) {
            return 0;
        }
        return restored;
    }

    function renderSummaryCards({ total, correct, wrong, unanswered, attemptId, recordHref }) {
        summary.innerHTML = `
            <div class="grid grid-cols-2 gap-2 md:grid-cols-4">
                <div class="rounded border border-slate-200 bg-white p-3">
                    <div class="text-xs font-black text-slate-500">총문항</div>
                    <div class="mono mt-1 text-2xl font-black text-slate-900">${total}</div>
                </div>
                <div class="rounded border border-green-200 bg-green-50 p-3">
                    <div class="text-xs font-black text-green-700">정답</div>
                    <div class="mono mt-1 text-2xl font-black text-green-700">${correct}</div>
                </div>
                <div class="rounded border border-red-200 bg-red-50 p-3">
                    <div class="text-xs font-black text-red-700">오답</div>
                    <div class="mono mt-1 text-2xl font-black text-red-700">${wrong}</div>
                </div>
                <div class="rounded border border-amber-200 bg-amber-50 p-3">
                    <div class="text-xs font-black text-amber-700">미입력</div>
                    <div class="mono mt-1 text-2xl font-black text-amber-700">${unanswered}</div>
                </div>
            </div>
            <div class="mt-3 flex flex-wrap items-center justify-between gap-2">
                <div class="text-sm font-black text-slate-700">${attemptId ? `저장 완료 (시도 #${attemptId})` : "로컬 채점 완료"}</div>
                <a href="${recordHref}" class="rounded bg-slate-900 px-3 py-2 text-xs font-black text-white hover:bg-black">기록 보기</a>
            </div>
        `;
        summary.classList.remove("hidden");
    }

    function toQuestionLabel(qNum) {
        return `${String(qNum).padStart(3, "0")}번`;
    }

    function formatStars(raw) {
        const n = Number.parseInt(String(raw ?? ""), 10);
        if (!Number.isFinite(n) || n <= 0) return "-";
        const safeN = Math.min(Math.max(n, 1), 5);
        return "★".repeat(safeN);
    }

    function formatPercent(raw) {
        const n = Number(String(raw ?? "").replace(/%/g, "").trim());
        if (!Number.isFinite(n)) return "-";
        let v = n;
        if (v >= 0 && v <= 1) v *= 100;
        v = Math.min(Math.max(v, 0), 100);
        const rounded = Math.round(v * 10) / 10;
        return Number.isInteger(rounded) ? `${rounded}%` : `${rounded.toFixed(1)}%`;
    }

    function buildScratchCellHtml(answer) {
        const safe = Number.parseInt(String(answer ?? ""), 10);
        const text = Number.isFinite(safe) ? String(safe) : "-";
        return `
            <div class="answer-scratch mono js-scratch" role="img" aria-label="정답 스크래치 영역">
                <span class="answer-value hidden">${text}</span>
                <canvas class="scratchCanvas"></canvas>
                <span class="scratch-hint">긁기</span>
            </div>
        `;
    }

    function buildPlainAnswerCellHtml(answer) {
        const safe = Number.parseInt(String(answer ?? ""), 10);
        const text = Number.isFinite(safe) ? String(safe) : "-";
        return `
            <div class="answer-scratch mono revealed" role="img" aria-label="정답 박스">
                <span class="answer-value">${text}</span>
            </div>
        `;
    }

    const REVEAL_WITHIN_MS = 3000;
    const REVEAL_REQUIRED_COUNT = 2;

    function setupScratchCanvas(canvas) {
        const rect = canvas.getBoundingClientRect();
        const width = Math.max(1, Math.floor(rect.width));
        const height = Math.max(1, Math.floor(rect.height));
        const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        const ctx = canvas.getContext("2d");
        if (!ctx) return null;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
        ctx.clearRect(0, 0, width, height);
        return { ctx, width, height };
    }

    function paintScratchSurface(canvas) {
        const setup = setupScratchCanvas(canvas);
        if (!setup) return;
        const { ctx, width, height } = setup;

        const grad = ctx.createLinearGradient(0, 0, 0, height);
        grad.addColorStop(0, "#D6DAE1");
        grad.addColorStop(0.5, "#BFC5CF");
        grad.addColorStop(1, "#AEB5C1");
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, width, height);

        const noiseCount = 250 + Math.floor(Math.random() * 201);
        for (let i = 0; i < noiseCount; i += 1) {
            const x = Math.random() * width;
            const y = Math.random() * height;
            const alpha = 0.12 + Math.random() * 0.10;
            const size = Math.random() < 0.82 ? 1 : 2;
            ctx.fillStyle = `rgba(255,255,255,${alpha.toFixed(3)})`;
            ctx.fillRect(x, y, size, size);
        }

        const strokeCount = 18 + Math.floor(Math.random() * 11);
        ctx.lineCap = "round";
        for (let i = 0; i < strokeCount; i += 1) {
            const x1 = Math.random() * width;
            const y1 = Math.random() * height;
            const len = 6 + Math.random() * 12;
            const angle = (Math.random() * 0.8) - 0.4;
            const x2 = x1 + (Math.cos(angle) * len);
            const y2 = y1 + (Math.sin(angle) * len);
            const alpha = 0.08 + Math.random() * 0.08;
            ctx.strokeStyle = `rgba(120,130,145,${alpha.toFixed(3)})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        ctx.strokeStyle = "rgba(255,255,255,0.22)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, 2.5);
        ctx.lineTo(width, 2.5);
        ctx.stroke();

        ctx.fillStyle = "rgba(40,55,80,0.08)";
        ctx.fillRect(0, height - 3, width, 3);
    }

    function eraseScratchAt(canvas, event, radius = 12) {
        const ctx = canvas.getContext("2d");
        if (!ctx) return;
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const prev = ctx.globalCompositeOperation;
        ctx.globalCompositeOperation = "destination-out";
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalCompositeOperation = prev;
    }

    function initScratchSurfaces(root) {
        const targets = root.querySelectorAll(".js-scratch");
        targets.forEach((box) => {
            const canvas = box.querySelector(".scratchCanvas");
            const valueNode = box.querySelector(".answer-value");
            if (!canvas || !valueNode) return;

            paintScratchSurface(canvas);

            let revealed = false;
            let windowStartedAt = 0;
            let lastRegion = null;
            let transitionCount = 0;

            const revealNow = () => {
                if (revealed) return;
                revealed = true;
                valueNode.classList.remove("hidden");
                box.classList.add("revealed");
            };

            const resetMotionWindow = (now, region) => {
                windowStartedAt = now;
                lastRegion = region;
                transitionCount = 0;
            };

            const classifyRegion = (event) => {
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;
                if (x < 0 || x > rect.width || y < 0 || y > rect.height) return "outside";

                const centerW = rect.width * 0.52;
                const centerH = rect.height * 0.64;
                const centerLeft = (rect.width - centerW) / 2;
                const centerTop = (rect.height - centerH) / 2;
                const centerRight = centerLeft + centerW;
                const centerBottom = centerTop + centerH;
                const insideCenter = x >= centerLeft && x <= centerRight && y >= centerTop && y <= centerBottom;
                return insideCenter ? "inside" : "outside";
            };

            const handleScratchMotion = (event, radius) => {
                if (revealed) return;
                eraseScratchAt(canvas, event, radius);
                const now = Date.now();
                const region = classifyRegion(event);
                if (!windowStartedAt || now - windowStartedAt > REVEAL_WITHIN_MS) {
                    resetMotionWindow(now, region);
                    return;
                }
                if (lastRegion == null) {
                    lastRegion = region;
                    return;
                }
                if (region !== lastRegion) {
                    transitionCount += 1;
                    lastRegion = region;
                }
                const roundTripCount = Math.floor(transitionCount / 2);
                if (roundTripCount >= REVEAL_REQUIRED_COUNT) revealNow();
            };

            let activePointerId = null;
            canvas.addEventListener("pointermove", (event) => {
                handleScratchMotion(event, 11 + Math.random() * 3);
            });
            canvas.addEventListener("pointerdown", (event) => {
                activePointerId = event.pointerId;
                try { canvas.setPointerCapture(event.pointerId); } catch (_a) {}
                handleScratchMotion(event, 13);
            });
            canvas.addEventListener("pointerup", (event) => {
                if (activePointerId === event.pointerId) activePointerId = null;
                try { canvas.releasePointerCapture(event.pointerId); } catch (_a) {}
            });
            canvas.addEventListener("pointercancel", (event) => {
                if (activePointerId === event.pointerId) activePointerId = null;
                try { canvas.releasePointerCapture(event.pointerId); } catch (_a) {}
            });
        });
    }

    function renderWrongTable(rows) {
        if (!rows.length) {
            wrongWrap.classList.add("hidden");
            wrongList.innerHTML = "";
            return;
        }

        wrongList.innerHTML = `
            <div class="overflow-x-auto">
                <table class="min-w-full border border-slate-200 bg-white text-xs font-bold text-slate-700">
                    <thead class="bg-slate-100 text-slate-500">
                        <tr>
                            <th class="border-b border-slate-200 px-2 py-2 text-left">문항</th>
                            <th class="border-b border-slate-200 px-2 py-2 text-left">내답</th>
                            <th class="border-b border-slate-200 px-2 py-2 text-left">난이도</th>
                            <th class="border-b border-slate-200 px-2 py-2 text-left">정답률</th>
                            <th class="border-b border-slate-200 px-2 py-2 text-left">정답</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${rows.map((row) => `
                            <tr class="odd:bg-white even:bg-slate-50">
                                <td class="border-b border-slate-100 px-2 py-2 mono">${toQuestionLabel(row.qnum)}</td>
                                <td class="border-b border-slate-100 px-2 py-2 mono">${row.myAnswer}</td>
                                <td class="border-b border-slate-100 px-2 py-2">${formatStars(row.stars)}</td>
                                <td class="border-b border-slate-100 px-2 py-2">${formatPercent(row.pCorrect)}</td>
                                <td class="border-b border-slate-100 px-2 py-2">${row.isCorrect ? buildPlainAnswerCellHtml(row.answer) : buildScratchCellHtml(row.answer)}</td>
                            </tr>
                        `).join("")}
                    </tbody>
                </table>
            </div>
        `;

        wrongWrap.classList.remove("hidden");
        initScratchSurfaces(wrongList);
    }

    async function getAuthedUser() {
        const app = window.JungdapApp || null;
        const sbClient = typeof app?.getSb === "function" ? app.getSb() : null;
        if (!sbClient?.auth) {
            alert("로그인 모듈이 아직 준비되지 않았습니다. 잠시 후 다시 시도해주세요.");
            return null;
        }

        const [{ data: sessionData }, { data: userData, error: userError }] = await Promise.all([
            sbClient.auth.getSession(),
            sbClient.auth.getUser()
        ]);

        const accessToken = sessionData?.session?.access_token || "";
        const user = userData?.user || null;
        if (userError || !user || !accessToken) {
            if (typeof app?.openAuth === "function") app.openAuth("login");
            setStatus("로그인이 필요합니다.");
            return null;
        }

        return { user, accessToken };
    }

    async function submitServerGrade({ year, subject, startQ, endQ, answers, userId, accessToken }) {
        const res = await fetch("/.netlify/functions/grade-mothertung", {
            method: "POST",
            headers: {
                "content-type": "application/json",
                authorization: `Bearer ${accessToken}`
            },
            body: JSON.stringify({
                year,
                subject,
                startQ,
                endQ,
                answers,
                user_id: userId
            })
        });

        const payload = await res.json().catch(() => ({}));
        if (!res.ok || !payload?.ok) {
            const message = payload?.detail || payload?.error || `HTTP_${res.status}`;
            throw new Error(String(message));
        }
        return payload;
    }

    function resetAll(message = "범위를 설정하고 생성 버튼을 눌러주세요.") {
        questionIds = [];
        questionList.innerHTML = "";
        wrongList.innerHTML = "";
        summary.classList.add('hidden');
        wrongWrap.classList.add('hidden');
        setSaveMeta({});
        updateActionButtons();
        setStatusPhase("idle", message);
    }

    function clampRange(start, end, min, max) {
        const safeStart = Math.min(Math.max(start, min), max);
        const safeEnd = Math.min(Math.max(end, min), max);
        if (safeStart > safeEnd) return null;
        return { start: safeStart, end: safeEnd };
    }

    function inputByPos(pos) {
        const qid = questionIds[pos];
        if (!qid) return null;
        return document.getElementById(`q-${qid}`);
    }

    function focusPos(pos) {
        const target = inputByPos(pos);
        if (target) target.focus();
    }

    function focusNext(pos) {
        for (let next = pos + 1; next < questionIds.length; next += 1) {
            if (inputByPos(next)) {
                focusPos(next);
                return;
            }
        }
    }

    function focusPrev(pos) {
        for (let prev = pos - 1; prev >= 0; prev -= 1) {
            if (inputByPos(prev)) {
                focusPos(prev);
                return;
            }
        }
    }

    function clearVisualState(input, mark) {
        input.classList.remove("border-green-500", "bg-green-50", "border-red-500", "bg-red-50", "border-amber-500", "bg-amber-50");
        input.classList.add("border-slate-200");
        if (!mark) return;
        mark.textContent = "·";
        mark.className = "mt-1 text-center text-xs font-black text-slate-300";
    }

    function applyResultState(input, mark, state) {
        input.classList.remove("border-slate-200", "border-green-500", "bg-green-50", "border-red-500", "bg-red-50", "border-amber-500", "bg-amber-50");
        if (state === "O") {
            input.classList.add("border-green-500", "bg-green-50");
            if (!mark) return;
            mark.textContent = "O";
            mark.className = "mt-1 text-center text-xs font-black text-green-600";
            return;
        }
        if (state === "X") {
            input.classList.add("border-red-500", "bg-red-50");
            if (!mark) return;
            mark.textContent = "X";
            mark.className = "mt-1 text-center text-xs font-black text-red-600";
            return;
        }
        input.classList.add("border-amber-500", "bg-amber-50");
        if (!mark) return;
        mark.textContent = "!";
        mark.className = "mt-1 text-center text-xs font-black text-amber-500";
    }

    function handleInputChange(event) {
        const input = event.target;
        const pos = Number(input.dataset.pos || -1);
        const qNum = Number(input.dataset.qnum || 0);
        const mark = document.getElementById(`res-${qNum}`);
        const value = input.value.trim();

        if (value === "") {
            clearVisualState(input, mark);
            queueDraftSave();
            return;
        }

        if (!/^[1-5]$/.test(value)) {
            input.value = "";
            clearVisualState(input, mark);
            queueDraftSave();
            return;
        }

        clearVisualState(input, mark);
        queueDraftSave();
        focusNext(pos);
    }

    function handleInputKeydown(event) {
        const input = event.target;
        const pos = Number(input.dataset.pos || -1);
        const value = input.value.trim();

        if (event.key === "Enter") {
            event.preventDefault();
            gradeExam();
            return;
        }
        if (event.key === "Backspace" && value === "") {
            event.preventDefault();
            focusPrev(pos);
            return;
        }
        if (event.key === "ArrowLeft" || event.key === "ArrowUp") {
            event.preventDefault();
            focusPrev(pos);
            return;
        }
        if (event.key === "ArrowRight" || event.key === "ArrowDown") {
            event.preventDefault();
            focusNext(pos);
            return;
        }
        if (event.key.length === 1 && !/[1-5]/.test(event.key)) {
            event.preventDefault();
        }
    }

    function handlePaste(event) {
        const input = event.target;
        const startPos = Number(input.dataset.pos || -1);
        const digits = (event.clipboardData?.getData("text") || "")
            .replace(/\s+/g, "")
            .split("")
            .filter((ch) => /[1-5]/.test(ch));

        if (!digits.length) return;

        event.preventDefault();
        let pos = startPos;
        for (const digit of digits) {
            const target = inputByPos(pos);
            if (!target) break;
            target.value = digit;
            const mark = document.getElementById(`res-${target.dataset.qnum}`);
            clearVisualState(target, mark);
            pos += 1;
        }
        queueDraftSave();
        focusPos(Math.min(pos, questionIds.length - 1));
    }

    function createInputs() {
        setStatusPhase("generating", "문항 생성 중...");
        const subject = subjectSelect.value;
        const { min, max } = getSubjectRange(subject);
        const start = Number.parseInt(startQ.value, 10);
        const end = Number.parseInt(endQ.value, 10);

        if (Number.isNaN(start) || Number.isNaN(end)) {
            alert("시작 번호와 끝 번호를 입력해주세요.");
            return;
        }

        const range = clampRange(start, end, min, max);
        if (!range) {
            alert(`범위는 ${min}번부터 ${max}번까지 설정할 수 있습니다.`);
            return;
        }

        startQ.value = String(range.start);
        endQ.value = String(range.end);
        questionIds = [];
        questionList.innerHTML = "";
        summary.classList.add("hidden");
        wrongWrap.classList.add("hidden");
        wrongList.innerHTML = "";
        setSaveMeta({});

        for (let q = range.start, pos = 0; q <= range.end; q += 1, pos += 1) {
            questionIds.push(q);
            const box = document.createElement("div");
            box.className = "border border-slate-200 bg-white p-2";
            box.innerHTML = `
                <div class="mono text-center text-xs font-black text-slate-400">${String(q).padStart(3, "0")}</div>
                <input id="q-${q}" data-qnum="${q}" data-pos="${pos}" type="text" inputmode="numeric" maxlength="1"
                    class="mono mt-1 w-full border-2 border-slate-200 bg-slate-50 p-2 text-center text-lg font-black outline-none focus:border-blue-500" />
                <div id="res-${q}" class="mt-1 text-center text-xs font-black text-slate-300">·</div>
            `;

            const input = box.querySelector("input");
            const mark = box.querySelector(`#res-${q}`);
            input.addEventListener("input", handleInputChange);
            input.addEventListener("keydown", handleInputKeydown);
            input.addEventListener("paste", handlePaste);
            clearVisualState(input, mark);
            questionList.appendChild(box);
        }

        const restored = restoreDraftForCurrentRange();
        updateActionButtons();
        if (restored > 0) {
            setStatusPhase("idle", `${range.start}~${range.end} 생성 완료 · ${restored}개 복원`);
        } else {
            setStatusPhase("idle", `${range.start}번부터 ${range.end}번까지 생성 완료`);
        }
        focusPos(0);
    }

    function clearInputs() {
        for (const qNum of questionIds) {
            const input = document.getElementById(`q-${qNum}`);
            const mark = document.getElementById(`res-${qNum}`);
            if (!input || !mark) continue;
            input.value = "";
            clearVisualState(input, mark);
        }
        clearCurrentDraft();
        summary.classList.add("hidden");
        wrongWrap.classList.add("hidden");
        wrongList.innerHTML = "";
        setSaveMeta({});
        setStatusPhase("idle", "입력을 초기화했습니다.");
        focusPos(0);
    }

    async function gradeExam() {
        if (!questionIds.length || gradeBusy) return;
        gradeBusy = true;
        updateActionButtons();
        setStatusPhase("grading", "채점/저장 중...");
        setSaveMeta({});

        try {
            const auth = await getAuthedUser();
            if (!auth) {
                setStatusPhase("idle", "로그인이 필요합니다.");
                return;
            }
            const { user, accessToken } = auth;
            const subject = subjectSelect.value;

            const payload = await submitServerGrade({
                year: MOTHERTUNG_YEAR,
                subject,
                startQ: questionIds[0],
                endQ: questionIds[questionIds.length - 1],
                answers: buildAnswerPayload(),
                userId: user.id,
                accessToken
            });

            const items = Array.isArray(payload.items) ? payload.items : [];
            const itemMap = new Map();
            for (const raw of items) {
                const qNum = Number.parseInt(String(raw?.item_no ?? ""), 10);
                if (!Number.isFinite(qNum)) continue;
                itemMap.set(qNum, raw);
            }

            const solvedRows = [];
            let localAttempted = 0;
            let localCorrect = 0;
            let localUnanswered = 0;

            for (const qNum of questionIds) {
                const input = document.getElementById(`q-${qNum}`);
                const mark = document.getElementById(`res-${qNum}`);
                if (!input || !mark) continue;

                const item = itemMap.get(qNum);
                const myAnswer = Number.parseInt(String(item?.my_answer ?? ""), 10);
                const isCorrect = item?.is_correct;

                if (!Number.isFinite(myAnswer)) {
                    localUnanswered += 1;
                    applyResultState(input, mark, "!");
                    continue;
                }

                localAttempted += 1;
                if (isCorrect === true) {
                    localCorrect += 1;
                    applyResultState(input, mark, "O");
                    solvedRows.push({
                        qnum: qNum,
                        myAnswer,
                        answer: item?.correct_answer,
                        stars: item?.stars,
                        pCorrect: item?.p_correct,
                        isCorrect: true
                    });
                } else if (isCorrect === false) {
                    applyResultState(input, mark, "X");
                    solvedRows.push({
                        qnum: qNum,
                        myAnswer,
                        answer: item?.correct_answer,
                        stars: item?.stars,
                        pCorrect: item?.p_correct,
                        isCorrect: false
                    });
                } else {
                    localUnanswered += 1;
                    applyResultState(input, mark, "!");
                }
            }

            const s = payload.summary || {};
            const total = Number.parseInt(String(s.total ?? questionIds.length), 10) || questionIds.length;
            const attempted = Number.parseInt(String(s.attempted ?? localAttempted), 10) || localAttempted;
            const correct = Number.parseInt(String(s.correct ?? localCorrect), 10) || localCorrect;
            const wrong = Number.parseInt(String(s.wrong ?? (attempted - correct)), 10) || (attempted - correct);
            const unanswered = Number.parseInt(String(s.unanswered ?? localUnanswered), 10) || localUnanswered;
            const attemptId = payload.attempt_id;
            const recordHref = `/records.html?year=${MOTHERTUNG_YEAR}&section=${encodeURIComponent(subject)}`;

            renderSummaryCards({
                total,
                correct,
                wrong,
                unanswered,
                attemptId,
                recordHref
            });
            renderWrongTable(solvedRows);

            saveDraftNow();
            setSaveMeta({ attemptId, href: recordHref });
            summary.scrollIntoView({ behavior: "smooth", block: "start" });
            setStatusPhase("done", `채점/저장 완료 · 채점 ${attempted}문항`);
        } catch (error) {
            console.error("[grader] grade-mothertung failed:", error);
            setStatusPhase("error", "채점/저장 실패");
            alert(`서버 채점/저장에 실패했습니다: ${String(error?.message || error)}`);
        } finally {
            gradeBusy = false;
            updateActionButtons();
        }
    }

    btnBuild.addEventListener("click", createInputs);
    btnClear.addEventListener("click", clearInputs);
    btnGrade.addEventListener("click", gradeExam);
    subjectSelect.addEventListener("change", () => {
        setDefaultRange();
        resetAll("과목이 바뀌어 범위를 다시 맞췄습니다.");
    });
    endQ.addEventListener("keydown", (event) => {
        if (event.key === "Enter") createInputs();
    });
    btnMenu.addEventListener("click", () => {
        mobileMenu.classList.toggle("hidden");
    });

    const allowedSubject = new Set(["humanities", "social", "science", "tech", "art", "mixed", "mock1", "mock2"]);
    if (allowedSubject.has(sectionFromQs)) {
        subjectSelect.value = sectionFromQs;
    }
    setDefaultRange();
    if (sectionFromQs && !allowedSubject.has(sectionFromQs)) {
        resetAll("선택한 영역은 마더텅 채점기 대상이 아니어서 기본 과목으로 열었습니다.");
    } else {
        resetAll();
    }
    updateActionButtons();
</script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="/app.js?v=20260228-0846"></script>
<script>
    window.JungdapApp?.setupSecretRoomHover({
        elementId: "room-of-requirement",
        hiddenColor: "#7092BE",
        hoverColor: "#7496C2",
        openColor: "#FFFFFF",
        requiredCount: 3,
        withinMs: 1500,
        resetMs: 1500
    });
</script>

</body>
</html>
